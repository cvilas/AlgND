# Project 0: Data Structures and Algorithms Nanodegree

## Big-O worst-case runtime computational efficiency

### Task0
- Efficiency: O(1)
- Rationale: Random access into a list given an index within that list is not dependent on the length of the list

### Task1
- Efficiency: O(4.n^2) = ~O(n^2)
- Rationale: We step through each record in the list of calls (which is O(n)) and check whether the receiving
 and calling numbers are already in the list of unique numbers (worst case O(2n)), making it O(2n^2). We then
 repeat the same procedure for list of texts.

### Task2
- Efficiency: O(2.n.log(n) + n) = ~O(n.log(n))
- Rationale: We go through the entire list of calls (O(n)) and for each one find the calling and receiving number
in the database of numbers (dictionary search - O(log(n))) and add call duration to them. Finally, we find the
number in the database that has been on call longest (another dictionary search - O(n)). We could avoid the final
dictionary search by maintaining a running update for the phone number with the longest duration as we go through
the list

### Task3:
- Efficiency:
- Rationale:

### Task4:
- Efficiency:
- Rationale:
