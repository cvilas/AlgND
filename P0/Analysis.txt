# Project 0: Data Structures and Algorithms Nanodegree

## Big-O worst-case runtime computational efficiency

### Task0
- Efficiency: O(1)
- Rationale: Random access into a list given an index within that list is not dependent on the length of the list

### Task1
- Efficiency: O(4.n^2) = ~O(n^2)
- Rationale: We step through each record in the list of calls (which is O(n)) and check whether the receiving
 and calling numbers are already in the list of unique numbers (worst case O(2n)), making it O(2n^2). We then
 repeat the same procedure for list of texts.

### Task2
- Efficiency: O(2.n.log(n) + n) = ~O(n.log(n))
- Rationale: We go through the entire list of calls (O(n)) and for each one find the calling and receiving number
in the database of numbers (dictionary search - O(log(n))) and add call duration to them. Finally, we find the
number in the database that has been on call longest (another dictionary search - O(n)). We could avoid the final
dictionary search by maintaining a running update for the phone number with the longest duration as we go through
the list

### Task3
- Efficiency: O(n.log(n))
- Rationale: Stepping through list of calls is O(n), extracting area code of the called number is not O(1) but not 
quite O(n) and therefore ignored, adding unique area code to existing list of called numbers is O(log(n)). After this
the list of area codes is sorted lexicographically. The complexity here depends on sorting algorithm, but it is likely
to be O(n.log(n))

### Task4
- Efficiency: O(8.n.log(n)) = ~O(n.log(n))
- Rationale: We go through list of calls and texts (each O(n)) and extract unique callers, texters, text receivers, 
and call receivers (each O(log(n)), and then we search again for unique callers who are not in the other lists created
above (O(log(n)). Finally we do a lexicographic sort which is O(n.log(n))
